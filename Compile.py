import Prefix
from Code import *
from Preprocess import preprocess
from Tokenize import tokenize
from Parse import parse

import inspect



class CompileError(Exception):
	pass


_cont = Sym(' cont')
_contList = Cons(_cont, nil)
_ret = Sym(' ret')
_retList = Cons(_ret, nil)
_dummy = Sym(' dummy')


def _finish(ret, cap, waiting, tail):
	if tail:
		ret += [
			Ld(_cont),
			cap,
			Call(1, notes = '_finish')
		]
	elif waiting:
		ret.append(cap)
	return ret


def c_branch(env, xpr, offset, waiting, tail, qq):
	cond = c_xpr(env, xpr.car, offset, True, False, qq)
	consequent = c_xpr(env, xpr.cdr.car, offset + len(cond) + 1, waiting, tail, qq)
	
	if xpr.cdr.cdr != nil:
		alternative = c_xpr(env, xpr.cdr.cdr.car, offset + len(cond) + len(consequent) + 2, waiting, tail, qq)
		consequent.append(Jmp(len(alternative)))
	else:
		alternative = _finish([], Lit(nil), waiting, tail)
		if alternative:
			consequent.append(Jmp(len(alternative)))
	
	cond.append(Br(len(consequent)))
	
	return cond + consequent + alternative

def c_assign(env, rest, offset, waiting, tail, qq):
	ret = c_xpr(env, rest.cdr.car, offset, True, False, qq)
	ret.append(St(rest.car))
	return _finish(ret, Ld(rest.car), waiting, tail)

def c_fn(env, rest, offset, waiting, tail, qq):
	return _finish([], Fn(Cons(_cont, rest.car), rest.cdr), waiting, tail)

def c_ccc(env, rest, offset, waiting, tail, qq):
	ret = c_xpr(env, rest.car, offset, True, False, qq)
	pos = offset + len(ret) + 3
	
	#This is the continuation that will be invoked by the tail of the user 
	#function if it returns normally.
	ret.append(Cont(_retList, pos))
	
	#This is the continuation that will be invoked if the user function 
	#explicitly calls it. It needs an extra parameter because such an 
	#argument will be automatically (and uselessly) generated by c_xpr. 
	#This argument must not be called _cont, because then it would 
	#clobber the legit _cont already in our environment. This continuation also 
	#needs to pop the previous continuation and the user function itself off 
	#the stack. This is dumb, and could be fixed with a little thought, I 
	#think.
	ret.append(Cont(clist((_dummy, _ret)), pos, 2))
	
	ret.append(Call(2))
	return _finish(ret, Ld(_ret), waiting, tail)

def c_quote(env, rest, offset, waiting, tail, qq):
	return _finish([], Lit(rest.car), waiting, tail)

def c_quasiquote(env, rest, offset, waiting, tail, qq):
	return c_xpr(env, rest.car, offset, waiting, tail, qq + 1)

def c_unquote(env, rest, offset, waiting, tail, qq):
	raise CompileError('unquote is undefined at quote level 0.')

def c_unquotesplicing(env, rest, offset, waiting, tail, qq):
	raise CompileError('unquotesplicing is undefined at quote level 0.')

def c_mac(env, rest, offset, waiting, tail, qq):
	name = rest.car
	parmList = rest.cdr.car
	body = rest.cdr.cdr
	_allMacros[name] = parmList, compMacro(env, body)
	return _finish([], Lit(nil), waiting, tail)

def c_apply(env, rest, offset, waiting, tail, qq):
	ret = c_xpr(env, rest.car, offset, True, False, qq)
	temp = Cont(_retList, 'Dummy value. See below.')
	ret.append(temp)
	ret += c_xpr(env, rest.cdr.car, offset + len(ret), True, False, qq)
	ret.append(Apply(1))
	temp.pos = offset + len(ret)
	return _finish(ret, Ld(_ret), waiting, tail)

def c_halt(env, rest, offset, waiting, tail, qq):
	return [Halt()]


_specialTable = {
	'branch' : c_branch,
	'fn' : c_fn,
	'assign' : c_assign,
	'ccc' : c_ccc,
	'quote' : c_quote,
	'quasiquote' : c_quasiquote,
	'unquote' : c_unquote,
	'unquotesplicing' : c_unquotesplicing,
	'mac' : c_mac,
	'apply' : c_apply,
	'halt' : c_halt,
}


_allMacros = {}


def macex(xpr, head = True):
	if isa(xpr, Cons):
		changed = False
		while isa(xpr, Cons) and isa(xpr.car, Sym) and xpr.car in _allMacros:
			parmList, func = _allMacros[xpr.car]
			c = Computer(func)
			args = unclist(xpr.cdr)
			wrangleArgs(c.env, parmList, args)
			while True:
				try:
					c.step()
				except StopIteration:
					break
			xpr = c.stack[0]
			changed = True
		if changed and debugCompile:
			print('EXPANDED TO %s' % xpr)
	return xpr

#This is provided for ExtractNames.
def getAllMacros():
	return _allMacros


def c_array(env, xpr, offset, waiting, tail, qq):
	ret = [Ld(Sym('array'))]
	temp = Cont(_retList, 'Dummy value. See below.')
	ret.append(temp)
	for sub in xpr:
		ret += c_xpr(env, sub, offset + len(ret), True, False, qq)
	ret.append(Call(len(xpr) + 1))
	temp.pos = offset + len(ret)
	return _finish(ret, Ld(_ret), waiting, tail)

def c_hash(env, xpr, offset, waiting, tail, qq):
	ret = [Ld(Sym('hash'))]
	temp = Cont(_retList, 'Dummy value. See below.')
	ret.append(temp)
	for k, v in xpr.items():
		ret += c_xpr(env, k, offset + len(ret), True, False, qq)
		ret += c_xpr(env, v, offset + len(ret), True, False, qq)
	ret.append(Call(2 * len(xpr) + 1))
	temp.pos = offset + len(ret)
	return _finish(ret, Ld(_ret), waiting, tail)


def c_qq(env, xpr, offset, waiting, tail, qq):
	if isa(xpr, Cons):
		head = xpr.car
		rest = xpr.cdr
		
		if head == Sym('unquote'):
			qq -= 1
			if qq == 0:
				return c_xpr(env, rest.car, offset, waiting, tail, qq)
		elif head == Sym('unquotesplicing'):
			qq -= 1
			if qq == 0:
				ret = c_xpr(env, rest.car, offset, waiting, tail, qq)
				ret.append(Splice())
				return ret
		elif head == Sym('quasiquote'):
			qq += 1
		
		ret = [Ld(Sym('list'))]
		temp = Cont(_retList, 'Dummy value. See below.')
		ret.append(temp)
		count = 1
		while True:
			if xpr == nil:
				break
			if isa(xpr, Cons):
				ret += c_xpr(env, xpr.car, offset + len(ret), True, False, qq)
				count += 1
				xpr = xpr.cdr
			else:
				ret += c_xpr(env, xpr, offset + len(ret), True, False, qq)
				ret.append(EndCap())
				count += 1
				break
		ret.append(Call(count))
		temp.pos = offset + len(ret)
		return _finish(ret, Ld(_ret), waiting, tail)
	
	if isa(xpr, KlipArray):
		return c_array(env, xpr, offset, waiting, tail, qq)
	
	if isa(xpr, KlipHash):
		return c_hash(env, xpr, offset, waiting, tail, qq)
		
	return [Lit(xpr)]


def c_body(env, xpr, offset, waiting, tail, qq):
	if xpr == nil:
		return _finish([], Lit(nil), waiting, tail)
	if xpr.cdr == nil:
		return c_xpr(env, xpr.car, offset, waiting, tail, qq)
	temp = c_xpr(env, xpr.car, offset, False, False, qq)
	return temp + c_body(env, xpr.cdr, offset + len(temp), waiting, tail, qq)


def c_cons(env, xpr, offset, waiting, tail, qq):
	head = xpr.car
	rest = xpr.cdr
	
	#Special forms:
	if isa(head, Sym):
		f = _specialTable.get(head.name, None)
		if f:
			return f(env, rest, offset, waiting, tail, qq)
	
	#ordinary combination:
	if tail:
		ret = c_xpr(env, xpr.car, offset, True, False, qq)
		ret.append(Ld(_cont))
		this = xpr.cdr
		count = 1
		while this != nil:
			ret += c_xpr(env, this.car, offset + len(ret), True, False, qq)
			this = this.cdr
			count += 1
		ret.append(Call(count))
	else:
		ret = c_xpr(env, xpr.car, offset, True, False, qq)
		temp = Cont(_retList, 'Dummy value. See below.')
		ret.append(temp)
		this = xpr.cdr
		count = 1
		while this != nil:
			ret += c_xpr(env, this.car, offset + len(ret), True, False, qq)
			this = this.cdr
			count += 1
		ret.append(Call(count))
		temp.pos = offset + len(ret)
		if waiting:
			ret.append(Ld(_ret))
	return ret


_xprTable = {
	Cons : c_cons,
	KlipArray : c_array,
	KlipHash : c_hash
}


def c_xpr(env, xpr, offset, waiting, tail, qq):
	if qq:
		return c_qq(env, xpr, offset, waiting, tail, qq)
	
	xpr = macex(xpr)
	
	#An attempt to deal with the nested fn forms that macros like lets 
	#generate. This quite accurately detects and corrects such nested fn forms, 
	#but it doesn't help because macro expansion isn't recursive (so at the 
	#time that this code runs, there are no nested fns). We need recursive 
	#macro expansion.
	#Note: one could call this process head call optimization.
	#Note: this by itself still won't work even with proper macro expansion. 
	#The head call optimizer must be able to look into innerArgs and discover 
	#any expressions that depend on innerParms, 'cuz that's the whole point of 
	#the lets macro.
	# if isa(xpr, Cons):
		# head = xpr.car
		# if isa(head, Cons) and head.car == Sym('fn'):
			# outerParms = head.cdr.car
			# outerArgs = xpr.cdr
			# outerBody = head.cdr.cdr
			
			# print('outer body', outerBody)
			
			# if outerBody.cdr == nil and isa(outerBody.car, Cons):
				# subHead = outerBody.car
				# if isa(subHead.car, Cons) and subHead.car.car == Sym('fn'):
					# innerParms = subHead.car.cdr.car
					# innerArgs = subHead.cdr
					# innerBody = subHead.car.cdr.cdr
					
					# print('\tthis xpr', xpr)
					# print('\touterParms, outerArgs', outerParms, outerArgs)
					# print('\tinnerParms, innerArgs', innerParms, innerArgs)
					
					# print('\tinnerBody', innerBody)
					
					# newParms = list(outerParms) + list(innerParms)
					# newArgs = list(outerArgs) + list(innerArgs)
					# print('\tnewParms, newArgs', newParms, newArgs)
					
					# newXpr = clist((
						# clist((Sym('fn'), clist(newParms), EndCapWrapper(innerBody))),
						# EndCapWrapper(clist(newArgs))))
					# print('\tNEW XPR', newXpr)
					
					# print('\t', xpr, ' -> ', newXpr)
					# return c_xpr(env, newXpr, offset, waiting, tail, qq)
	
	f = _xprTable.get(type(xpr), None)
	if f:
		return f(env, xpr, offset, waiting, tail, qq)
	
	if isa(xpr, Sym):
		return _finish([], Ld(xpr), waiting, tail)
	
	return _finish([], Lit(xpr), waiting, tail)

_compCache = {}

def _doComp(env, body):
	if debugCompile:
		print('COMPILING', body)
	try:
		ret = c_body(env, body, 0, True, True, 0)
	except CompileError as e:
		print('ERROR WHILE COMPILING:\n', body)
		raise e
	if debugCompile:
		print('COMPILED')
		dumpCode(ret)
	return ret

def comp(env, parmList, body):
	if body in _compCache:
		code = _compCache[body]
	else:
		code = _doComp(env, body)
		_compCache[body] = code
	
	ret = LitFunc(Func(env, code), None, parmList, 0)
	return ret


def compFile(env, tree, offset = 0, main = True):
	if debugCompile:
		print('COMPILING FILE', tree)
	code = []
	for xpr in tree:
		try:
			if isa(xpr, Cons) and xpr.car == Sym('include'):
				fname = xpr.cdr.car
				fin = open(fname, 'r')
				sub = parse(tokenize(preprocess(fin.read()), fname), fname)
				fin.close()
				code += compFile(env, sub, offset + len(code), False)
			else:
				#This seems super inefficient. But I don't see any other way of allowing macros to see earlier function definitions.
				code.append(Fn(_contList, clist((xpr, ))))
				code.append(Cont(_retList, len(code) + 2))
				code.append(Call(1, notes = 'compFile'))
		except CompileError as e:
			print('ERROR WHILE COMPILING TOPLEVEL XPR:\n', xpr)
			raise e
	if main:
		code.append(Halt())
		if debugCompile:
			print('COMPILED FILE')
			dumpCode(code)
	return code

def compMacro(env, tree):
	if debugCompile:
		print('COMPILING MACRO', id(env), tree)
	try:
		code = c_body(env, tree, 0, True, False, 0)
		code.append(Halt())
	except CompileError as e:
		print('ERROR WHILE COMPILING MACRO:\n', tree)
		raise e
	if debugCompile:
		print('COMPILED MACRO')
		dumpCode(code)
	return Func(env, code)


if __name__ == '__main__':
	import sys
	
	fin = open(sys.argv[1], 'r')
	tree = parse(tokenize(preprocess(fin.read()), sys.argv[1]), sys.argv[1])
	fin.close()
	
	print(tree)
	
	code = comp(None, tree)

